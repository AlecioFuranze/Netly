> ###### The active development branch is [_'dev'_](https://github.com/alec1o/Netly/tree/dev), while the production branch is [_'main'_](https://github.com/alec1o/Netly/tree/main).
> <sup>Netly version 4 will be released soon, help validating the new way of interacting with netly. [_See
more_](https://github.com/alec1o/Netly/discussions/36#discussion-6204441)<sup>

<div align="right">
<table>
<td aligh="right">
<p></p>
<sup>‚≠ê Your star is the light at the end of our tunnel.<br> Lead us out of the darkness by starring <a href="https://github.com/alec1o/Netly">Netly on GitHub</a>.<br> Star me please, I beg you! üíô</sup>
</td>
</table>
</div>

<br>

<h1 align="center"><a href="https://github.com/alec1o/Netly">Netly</a></h1>

<h6 align="center"><sub>
powered by <a href="https://github.com/alec1o">ALEC1O</a><sub/>
</h6>

<div align="center">
  <a href="#">
    <img align="center" src="static/logo/netly-logo-3.png" width="128px" alt="netly logo">
  </a>
</div>

##### Project

> <sub>Get basic information about this project called [Netly](https://github.com/alec1o/Netly)</sub>

<table>
    <tr>
      <th align="center" valign="center"><sub><strong>Overview</strong></sub></th>
<td>
<br>

<sub>Netly is a powerful C# socket library that simplifies network communication. It supports HTTP, TCP, SSL/TLS, UDP,
Reliable UDP (RUDP)
and WebSocket protocols, making it ideal for building multiplayer games, chat applications, and more.</sub>

<br>
</td>
    </tr>
    <tr>
      <th align="center" valign="center"><sub><strong>Link's</strong></sub></th>
<td>

> <sub>Official website</sub>

| <sub>Repository</sub> | <sub>Documentation</sub> |
| :--        | :--           |
|<sub><a href="https://github.com/alec1o/Netly"><i>github.com/alec1o/netly</i></a></sub> | <sub><a href="https://netly.docs.kezero.com"><i>netly.docs.kezero.com</i></a></sub> |

<br>
</td>
    </tr>
    <tr>
      <th align="center" valign="center"><sub><strong>Install</strong></sub></th>
<td>

> <sub>Official publisher</sub>

| <sub>Nuget</sub>                                                    | <sub>Unity Asset Store</sub>                                                                     |
|---------------------------------------------------------------------|--------------------------------------------------------------------------------------------------|
| <sub>Install on [Nuget](https://www.nuget.org/packages/Netly)</sub> | <sub>Install on [Asset Store ](https://assetstore.unity.com/packages/tools/network/225473)</sub> |
</td>
    </tr>
    <tr>
        <th align="center" valign="center"><sub><strong>Sponsor</strong></sub></th>
<td>

> <sub>Official sponsors</sub>

<div>
    <a href="https://www.kezero.com/?invite_user='Netly'"><img alt="KeZero sponsor notice" src="/static/KeZero%20sponsor.png" height="30px" /></a>
    <h6></h6> <!-- padding and margin -->
    <a href="https://www.jetbrains.com/community/opensource/"><img alt="JetBrains sponsor notice" src="/static/JetBrains%20sponsor.png" height="30px" /></a>
</div>

<br>
</td>
    </tr>
    <tr>
        <th align="center" valign="center"><sup><strong>Supporter</strong></sup></th>
<td>
<h6>Why Contribute to Netly</h6>

> <sub>Solve Real-World Challenges: Netly simplifies socket programming, making it accessible for developers. By
> contributing, you‚Äôll directly impact how games, chat applications, and real-time systems communicate.</sub>

> <sub>Learn and Grow: Dive into the world of networking, encryption, and protocols. Gain practical experience by
> working on a versatile library used across platforms.</sub>

> <sub>Be Part of Something Bigger: Netly is open source, and your contributions will benefit the entire community. Join
> a passionate group of developers who believe in collaboration and knowledge sharing.</sub>

> <sub>Code, Ideas, and Feedback: Whether you‚Äôre a seasoned developer or just starting out, your code, ideas, and
> feedback matter. Every line of code, every suggestion, and every bug report contributes to Netly‚Äôs growth.</sub>

</td>
    </tr>
</table>

<br>

##### Versions

> <sub>Notable changes</sub>

<table>
<tr> <!-- title -->
<th><sub>v1.x.x</sub></th>
<th><sub>v2.x.x</sub></th>
<th><sub>v3.x.x</sub></th>
<th><sub>v4.x.x</sub></th>
</tr>
<tr> <!-- status -->
<td valign="center" align="center"><sup><sub><i>Legacy</i></sub></sup></td>
<td valign="center" align="center"><sup><sub><i>Legacy</i></sub></sup></td>
<td valign="center" align="center"><sup><sub><i>Stable</i></sub></sup></td>
<td valign="center" align="center"><sup><sub><i>Development</i></sub></sup></td>
</tr>
<tr> <!-- row #1 -->
<td valign="top" align="left"><sub>TCP Support</sub></td>
<td valign="top" align="left"><sub>TCP with <a href="https://bit.ly/message-framing">Message Framing support</a></sub></td>
<td valign="top" align="left"><sub>TCP with TLS/SSL support</sub></td>
<td valign="top" align="left"><sub>HTTP client and server support</sub></td>
</tr>
<tr> <!-- row #2 -->
<td valign="top" align="left"><sub>UDP Support</sub></td>
<td valign="top" align="left"><sub>TCP and UDP performance increase</sub></td>
<td valign="top" align="left"><sub>UDP with connection (timeout response)</sub></td>
<td valign="top" align="left"><sub>Reliable UDP (RUDP) client and server support</sub></td>
</tr>
<tr> <!-- row #3 -->
<td valign="top" align="left"></td>
<td valign="top" align="left"></td>
<td valign="top" align="left"><sub>New <a href="https://bit.ly/message-framing">Message Framing</a> protocol and performance increase</sub></td>
<td valign="top" align="left"><sub>WebSocket client and server support</sub></td>
</tr>
<tr> <!-- row #4 -->
<td valign="top" align="left"></td>
<td valign="top" align="left"></td>
<td valign="top" align="left"><sub>Upgrade to <a href="https://github.com/alec1o/Byter">Byter 2.0</a></sub></td>
<td valign="top" align="left"><sub>Upgrade to <a href="https://github.com/alec1o/Byter">Byter 3.0</a></sub></td>
</tr>
<tr> <!-- row #4 -->
<td valign="top" align="left"></td>
<td valign="top" align="left"></td>
<td valign="top" align="left"><sub><a href="https://github.com/docsifyjs/docsify">Docsify</a> as documentation framework</sub></td>
<td valign="top" align="left"><sub>Documentation improvement by <a href="https://github.com/dotnet/docfx">DocFx</a></sub></td>
</tr>
<tr> <!-- row #5 -->
<td valign="top" align="left"></td>
<td valign="top" align="left"></td>
<td valign="top" align="left"></td>
<td valign="top" align="left"><sub>Syntax and internal improvement</sub></td>
</tr>
<tr> <!-- row #6 -->
<td valign="top" align="left"></td>
<td valign="top" align="left"></td>
<td valign="top" align="left"></td>
<td valign="top" align="left"><sub>XML comments improvement</sub></td>
</tr>
</table>

<br>

##### Integrations

> <sub>Technical descriptions about integrations</sub>

<table>
    <tr valign="top" align="left">
        <th><sub>List of tested platforms</sub></th>
<td valign="top" align="left">
<br>

- <sub>[.NET](https://dotnet.microsoft.com) (SDK)</sub>
- <sub>[Mono](https://mono-project.com) (SDK)</sub>
- <sub>[Unity](https://unity.com) (Engine)</sub>
- <sub>[Operating system](https://en.wikipedia.org/wiki/Operating_system) (OS)</sub>
    - <sub>Linux</sub>
    - <sub>Windows</sub>
    - <sub>Android</sub>
    - <sub>iOS and macOS</sub><br><br>
    - <sub><strong>Notice</strong>: <i>This library might run on all devices. If it doesn't work on any device, it
      should be considered a bug and reported.<i><sub>

<br>
</td>
    </tr>
    <tr valign="top" align="left">
        <th><sub>Dependencies</sub></th>
<td valign="top" align="left">
<br>

- <sub>[Byter](https://github.com/alec1o/Byter)</sub>

<br>
</td>
    </tr>
    <tr valign="top" align="left">
        <th><sub>Build</sub></th>
<td valign="top" align="left">
<br>

> ###### Build dependencies

- <sub>[Git](http://git-scm.com/)</sub>
- <sub>[.NET](http://dot.net)</sub>

> ###### Build step-by-step

```rb
# 1. clone project
$ git clone "https://github.com/alec1o/Netly" netly 

# 2. build project
$ dotnet build "netly/" -c Release -o "netly/bin/"

# NOTE:
# Netly.dll require Byter.dll because is Netly dependency
# Netly.dll and Byter.dll have on build folder <netly-path>/bin/
```

<br>
</td>
    </tr>
    <tr valign="top" align="left">
        <th><sub>Features</sub></th>
<td valign="top" align="left">
<br>

> <sub>Below are some missing features that are planned to be added in later versions.</sub><br>

- <sub>``N/A``</sub>

<br>
</td>
    </tr>
</table>

<br>

##### Examples

> <sub>Code highlights</sub>

<table>
<tr>
<th align="center" valign="top"><sub>TCP<strong></strong></sub></th>
<td width="100%">
<details><summary>üìÑ <strong><sup><sub>Client</sub></sup></strong></summary>

```csharp
using Netly;

TCP.Client client = new TCP.Client(framing: true);
```

```csharp
client.On.Open(() =>
{   
    printf("connection opened");
});

client.On.Close(() =>
{
    printf("connetion closed");
});

client.On.Error((exception) =>
{
    printf("connection erro on open");
});

client.On.Data((bytes) =>
{
    printf("connection receive a raw data");
});

client.On.Event((name, data) =>
{
    printf("connection receive a event");
});

client.On.Modify((socket) =>
{
    printf("called before try open connection.");
});

client.On.Encryption((certificate, chain, errors) =>
{
    // Only if client.IsEncrypted is enabled
    printf("validate ssl/tls certificate");
    // return true if certificate is valid
    return true;
});
```

```csharp
// open connection if closed
client.To.Open(new Host("127.0.0.1", 8080));

// close connection if opened
client.To.Close();

// send raw data if connected
client.To.Data(new byte[2] { 128, 255 });
client.To.Data("hello world", NE.Encoding.UTF8);

// send event if connected
client.To.Event("name", new byte[2] { 128, 255 });
client.To.Event("name", "hello world", NE.Encoding.UTF8); 

// enable encryption (must call before client.To.Open)
client.To.Encryption(true); 
```

</details>
<details><summary>üìÑ <strong><sup><sub>Server</sub></sup></strong></summary>

```csharp
using Netly;

TCP.Server server = new TCP.Server(framing: true);
```

```csharp
server.On.Open(() =>
{   
    printf("connection opened");
});

server.On.Close(() =>
{
    printf("connection closed");
});

server.On.Error((exception) =>
{
    printf("connection error on open");
});

server.On.Accept((client) =>
{
    client.On.Modify((socket) =>
    {
        printf("modify client socket e.g Enable NoDelay");
    });

    client.On.Open(() =>
    {
        printf("client connected");
    });
    
    client.On.Data((bytes) =>
    {
        printf("client receive a raw data");
    });
    
    client.On.Event((name, bytes) =>
    {
        printf("client receive a event");
    });
    
    client.On.Close(() =>
    {
        printf("client disconnected");
    });
});

server.On.Modify((socket) =>
{
    printf("called before try open connection.");
});
```

```csharp
// open connection
server.To.Open(new Host("1.1.1.1", 1111)); 

// close connection
server.To.Close();

// enable encryption support (must called before server.To.Open)
server.To.Encryption(enable: true, @mypfx, @mypfxpassword, SslProtocols.Tls12);

// broadcast raw data for all connected client
server.To.DataBroadcast("text buffer");
server.To.DataBroadcast(new byte[] { 1, 2, 3 });

// broadcast event (netly event) for all connected client
server.To.EventBroadcast("event name", "text buffer");
server.To.EventBroadcast("event name", new byte[] { 1, 2, 3 });
```

</details>
</td>
</tr>

<tr><th></th></tr>

<tr>
<th align="center" valign="top"><sub>UDP<strong></strong></sub></th>
<td>
<details><summary>üìÑ <strong><sup><sub>Client</sub></sup></strong></summary>

```csharp
using Netly;

UDP.Client client = new UDP.Client();
```

```csharp
client.On.Open(() =>
{
    printf("connection opened");
});

client.On.Close(() =>
{
    printf("connection closed");
});

client.On.Error((exception) =>
{
    printf("connection error on open");
});

client.On.Data((bytes) =>
{
    printf("connection received a raw data");
});

client.On.Event((name, eventBytes) =>
{
    printf("connection received a event");
});

client.On.Modify((socket) =>
{
   printf("called before try open connection.");
});
```

```csharp 
// open connection if closed
client.To.Open(new Host("127.0.0.1", 8080));

// close connection if opened
client.To.Close();

// send raw data if connected
client.To.Data(new byte[2] { 128, 255 });
client.To.Data("hello world", NE.Encoding.UTF8);

// send event if connected
client.To.Event("name", new byte[2] { 128, 255 });
client.To.Event("name", "hello world", NE.Encoding.UTF8); 
```

</details>
<details><summary>üìÑ <strong><sup><sub>Server</sub></sup></strong></summary>

```csharp
using Netly;

UDP.Server server = new UDP.Server();
```

```csharp
server.On.Open(() =>
{
    printf("connection opened");
});

server.On.Close(() =>
{
    printf("connection closed");
});

server.On.Error((exception) =>
{
    printf("connection error on open");
});

server.On.Accept((client) =>
{
    client.On.Open(() =>
    {
        printf("client connected");
    });
    
    client.On.Close(() =>
    {
        // Only if use connection is enabled.
        printf("client disconnected");
    });
    
    client.On.Data((bytes) =>
    {
        printf("client received a raw data");
    });
    
    client.On.Event((name, bytes) =>
    {
        printf("client received a event");
    });
});
```

```csharp
// open connection
server.To.Open(new Host("127.0.0.1", 8080));

// close connection
server.To.Close();

// broadcast raw data for all connected client
server.To.DataBroadcast("text buffer");
server.To.DataBroadcast(new byte[] { 1, 2, 3 });

// broadcast event (netly event) for all connected client
server.To.EventBroadcast("event name", "text buffer");
server.To.EventBroadcast("event name", new byte[] { 1, 2, 3 });
 
```

</details>
</td>
</tr>

<tr><th></th></tr>

<tr>
<th align="center" valign="top"><sub>HTTP<strong></strong></sub></th>
<td>
<details><summary>üìÑ <strong><sup><sub>Client</sub></sup></strong></summary>

```csharp
using Netly;

HTTP.Client client = new HTTP.Client();

// add http header for request
client.Headers.Add("Content-Type", "json");
client.Headers.Add("Token", "ImGui.h");

// add http url queries e.g: https://www.alec1o.com/?page=about&version=4
client.Queries.Add("page", "about");
client.Queries.Add("version", "4");

// set request timeout (ms) default 15s (15000ms), 0 or negative value means infinite timeout.
client.Timeout = 6000; // 6s

// is opened: while is requesting
bool isFetching = client.IsOpened;
```

```csharp
HttpClient http = null;

// called before try connect to server
// modify the HttpClient object
client.On.Modify((HttpClient instance) =>
{
    http = instance;
});

// connection is opened and fetch server.
client.On.Open((response) =>
{
    // you can use "http" instance on this scope (isn't null)
    if (http.<foo> == <bar>) { ... }
});

// erro on fetch, it can be timeout or whatever error
// but if you receives error it mean the operation is called or done
client.On.Error((Exception exception) =>
{
    Ny.Logger.PushError(exception);
});

// connection is closed with fetch server.
client.On.Close(() =>
{
     if (http.<bar> == <foo>) { ... }
});
```

```csharp

// used to fetch a server
client.To.Open("method e.g GET", "url", "body, allow null");

// used for cancel opened request
client.To.Close();

```

</details>
<details><summary>üìÑ <strong><sup><sub>Server</sub></sup></strong></summary>

```csharp
using Netly;

HTTP.Server server = new HTTP.Server();

// return true if server is serve http context
bool isServe = server.IsOpened;

```

```csharp

server.On.Open(() =>
{
    // http server opened 
});
server.On.Close(() =>
{
    // http server closed 
});

server.On.Error((exception) =>
{
    // http server open error
});

server.On.Modify((httpListener) =>
{
    // HttpListener instance, called before try open connection.    
});

// Open http server connection
server.To.Open(new Uri("http://127.0.0.1:8080/"));

// Close http server connection
server.To.Close();
```

##### Map

```csharp
// Map path
server.Map.Get("/", async (req, res) => {
    // Handle async: GET
})

server.Map.Post("/user", (req, res) => {
    // Handle sync: POST
});

// map using dynamic URL
server.Map.Delete("/post/{userId}/group/{groupId}", async (req, res)) => 
{
    string userId = req.Param["userId"];
    string groupId = req.Param["groupId"];
    
    // Handle async: Delete from dynamic URL path 
});

server.Map.WebSocket("/echo", (req, ws) =>
{
    // Handle websocket connection from path
});

/*
You can map: 
 * Get     # get request
 * Post    # post request
 * Delete  # delete request
 * Put     # put request
 * Patch   # patch request
 * Trace   # trace request
 * Options # options request
 * Head    # head request, (only head)
 * All     # all http nethod request
 * WebSocket   # websocket request
*/
    
```

##### Middleware

```csharp
/* Note: Callback return
    true: next callback can be executed
    false: next or others callback can't executed

    Note: Middlewares is executed in added order
    Global middleware have more priority than Local middleware
*/

server.Middleware.Add(async (req, res) => {
    // e.g Verify user location
    
    // success, execute next callback
    return true;
});

// Global middleware
server.Middleware.Add(async (req, res) => {
    // e.g verify banned IP
    
    // success, execute next callback
    return true;
});

// Local middleware
server.Middleware.Add("/admin", async (req, res) => {
    // e.g Detect if the ip is allowed to access
     
    if(Foo.Bar(req) == false)
    {
        if (Foo.Bar() == true)
        {
            await res.Redirect("https://www.example.com");
        }
        else
        {
            res.Header.Add("Content-Type", "application/json;charset=UTF-8");
            await res.Send(404, "Response Content Here");   
        }            
    }
          
    // fail, stop and close connection if is opened
    return false;
});

// Local Middleware
server.Middleware.Add("/dashboard", async (req, res) =>
{
    // e.g Check session from cookies.
    return Foo.Bar(req.Cookies);
});
```

</details>
</td>
</tr>


<tr><th></th></tr>

<tr>
<th align="center" valign="top"><sub>RUDP<strong></strong></sub></th>
<td>
<details><summary>üìÑ <strong><sup><sub>Client</sub></sup></strong></summary>

```csharp
using Netly;

RUDP.Client client = new RUDP.Client();
```

```csharp
client.On.Open(() =>
{
    printf("connection opened");
});

client.On.Close(() =>
{
    printf("connection closed");
});

client.On.Error((exception) =>
{
    printf("connection error on open");
});

client.On.Data((bytes, type) =>
{
    printf("connection received a raw data");
});

client.On.Event((name, bytes, type) =>
{
    printf("connection received a event");
});

client.On.Modify((socket) =>
{
    printf("called before try open connection.");
});
```

```csharp
// open connection if closed
client.To.Open(new Host("127.0.0.1", 8080));

// close connection if opened
client.To.Close();

// send raw data if connected
client.To.Data(new byte[2] { 128, 255 }, RUDP.Unreliable);
client.To.Data("hello world", NE.Encoding.UTF8, RUDP.Reliable);

// send event if connected
client.To.Event("name", new byte[2] { 128, 255 }, RUDP.Unreliable);
client.To.Event("name", "hello world", NE.Encoding.UTF8, RUDP.Reliable);
```

</details>
<details><summary>üìÑ <strong><sup><sub>Server</sub></sup></strong></summary>

```csharp
using Netly;

RUDP.Server server = new RUDP.Server();
```

```csharp
server.On.Open(() =>
{
    printf("connection opened");
});

server.On.Close(() =>
{
    printf("connection closed");
});

server.On.Error((exception) =>
{
    printf("connection error on open");
});

server.On.Accept((client) =>
{
    client.On.Open(() =>
    {
        printf("client connected");
    });
    
    client.On.Close(() =>
    {
        // Only if use connection is enabled.
        printf("client disconnected");
    });
    
    client.On.Data((bytes, type) =>
    {
        if (type == RUDP.Reliable) { ... }
        else if (type == RUDP.Unreliable) { ... }
        else { /* NOTE: it's imposible */ }
        
        printf("client received a raw data");
    });
    
    client.On.Event((name, type) =>
    
        if (type == RUDP.Reliable) { ... }
        else if (type == RUDP.Unreliable) { ... }
        else { /* NOTE: it's imposible */ }
        
        printf("client received a event");
    });    
});
```

```csharp
// open connection
server.To.Open(new Host("127.0.0.1", 8080));

// close connection
server.To.Close();

// broadcast raw data for all connected client
server.To.DataBroadcast("text buffer", RUDP.Unreliable);
server.To.DataBroadcast(new byte[] { 1, 2, 3 }, RUDP.Reliable);

// broadcast event (netly event) for all connected client
server.To.EventBroadcast("event name", "text buffer", RUDP.Unreliable);
server.To.EventBroadcast("event name", new byte[] { 1, 2, 3 }, RUDP.Reliable);
```

</details>
</td>
</tr>

<tr><th></th></tr>

<tr>
<th align="center" valign="top"><sub>WebSocket<strong></strong></sub></th>
<td>
<details><summary>üìÑ <strong><sup><sub>Client</sub></sup></strong></summary>

```csharp
using Netly;

HTTP.WebSocket client = new HTTP.WebSocket();
```

```csharp
client.On.Open(() =>
{
    // websocket connection opened
});

client.On.Close(() =>
{
    // websocket connection closed
});

client.On.Error((exception) =>
{
    // error on open websocket connectin
});

client.On.Data((bytes, type) =>
{
    if (type == HTTP.Binary) { ... }
    else if (type == HTTP.Text) { ... }
    else { /* NOTE: it's imposible */ }
    
    // raw data received from server
});

client.On.Event((name, bytes, type) =>
{
    if (type == HTTP.Binary) { ... }
    else if (type == HTTP.Text) { ... }
    else { /* NOTE: it's imposible */ }
    
    // event received from server
});

client.On.Modify((wsSocket) =>
{
    // modify websocket socket
});
```

```csharp
// open websocket client connection
client.To.Open(new Uri("ws://127.0.0.1:8080/echo"));

// close websocket client connection
client.To.Close();

// send raw data for server
//      text message
client.To.Data("my message", HTTP.Text);
//      binnary message
client.To.Data(NE.GetBytes("my buffer"), HTTP.Binary);

// send event (netly event) for server
//      text message
client.To.Event("event name", "my message", HTTP.Text);
//      binnary message
client.To.Data("event name", NE.GetBytes("my buffer"), HTTP.Binary); 
```

</details>
<details><summary>üìÑ <strong><sup><sub>Server</sub></sup></strong></summary>

```csharp
using Netly;
using Netly.Interfaces;

HTTP.Server server = new HTTP.Server();

IHTTP.WebSocket[] Clients = server.WebSocketClients;
```

```csharp
server.Map.WebSocket("/chat/{token}", async (req, ws) =>
{
    // Accept websocket from dynamic path
    string token = req.Params["token"];
    
    // validate websocket connection from params
    if (Foo.Bar(token) == false)
    {
        ws.To.Close();
    }
    
    ws.On.Modify(...);
    ws.On.Open(...);
    ws.On.Close(...);
    ws.On.Data(...);
    ws.On.Event(...);
});


server.Map.Websocket("/echo", (req, ws) =>
{
    // Handle websocket on /echo path
    
    ws.On.Modify((wsSocket) =>
    {
        // modify server-side websocket ocket
    });
    
    ws.On.Open(() =>
    {
        // server-side websocket connection opened
    });
    
    ws.On.Close(() =>
    {
        // server-side websocket connection closed
    });
    
    ws.On.Data((bytes, type) =>
    {
        if (type == HTTP.Binary) { ... }
        else if (type == HTTP.Text) { ... }
        else { /* NOTE: it's imposible */ }
        
        // server-side websocket received raw data
    });
    
    ws.On.Event((name, bytes, type) =>
    {
        if (type == HTTP.Binary) { ... }
        else if (type == HTTP.Text) { ... }
        else { /* NOTE: it's imposible */ }
        
        // server-side websocket received event
    });
});
```

```csharp
server.On.Open(() =>
{
    // http server opened 
});
server.On.Close(() =>
{
    // http server closed 
});

server.On.Error((exception) =>
{
    // http server open error
});

server.On.Modify((httpListener) =>
{
    // HttpListener instance, called before try open connection.    
});

// Open http server connection
server.To.Open(new Uri("http://127.0.0.1:8080/"));

// Close http server connection
server.To.Close();
```

```csharp
// open websocket client connection
server.To.Open(new Uri("ws://127.0.0.1:8080/echo"));

// close websocket client connection
server.To.Close();

// broadcast raw data for all connected websocket socket
//      text message
server.To.WebsocketDataBroadcast("my message", HTTP.Text);
//      binnary message
server.To.WebsocketDataBroadcast(NE.GetBytes("my buffer"), HTTP.Binary);

// broadcast event (netly event) for all connected websocket socket
//      text message
server.To.WebsocketEventBroadcast("event name", "my message", HTTP.Text);
//      binnary message
server.To.WebsocketEventBroadcast("event name", NE.GetBytes("my buffer"), HTTP.Binary); 
```

</details>

<sup>[``Community examples``](https://github.com/alec1o/Netly/issues/43) <sup> From issues</sup></sup>

<a href="###"><img src="/static/transparent-horizontal-1px-2048px.png" width="100%"><a/>

</td>

</tr>
</table>

<br>

##### Usage

> <sub>Integration and interaction example codes</sub>


<table>

<tr>
<th align="center" valign="top"><sub><strong>Standard</strong></sub></th>
<td>
<details><summary>üìÑ <strong><sup><sub>Console</sub></sup></strong></summary>

```csharp
using System;
using Netly;

public class Program
{
    private static void Main(string[] args)
    {
        UDP.Client client = new UDP.Client();
        
        client.On.Open(() =>
        {
            Console.WriteLine(<some-text-here>);
        };
            
        client.On.Close(() =>
        {
            Console.WriteLine(<some-text-here>);
        };
            
        client.On.Error((exception) =>
        {
            Console.WriteLine(<some-text-here>);
        };
        
        while(true)
        {
            if(!client.IsOpened)
            {
                client.To.Open(new Host("1.1.1.1", 1111));
            }
            else
            {
                Console.WriteLine("Message: ");
                string message = Console.ReadLine();
                client.To.Data(message ?? "No message.", NE.Encoding.UTF8);
            }
        }
    }
}
```

</details>
</td>
</tr>

<tr><th></th></tr>

<tr>
<th align="center" valign="top"><sub><strong>Flax Engine</strong></sub></th>
<td>
<details><summary>üìÑ <strong><sup><sub>Script</sub></sup></strong></summary>

```csharp
using System;
using FlaxEngine;
using Netly;

public class Example : Script
{
    public string message;
    
    internal UDP.Client client;
    
    public override void Awake()
    {
        client = new UDP.Client();        
        
        client.On.Open(() =>
        {
            Debug.Log(<some-text-here>);
        };
            
        client.On.Close(() =>
        {
            Debug.Log(<some-text-here>);
        };
            
        client.On.Error((exception) =>
        {
            Debug.Log(<some-text-here>);
        };
    }
    
    public override void Start()
    {
        client.To.Open(new Host("1.1.1.1", 1111));
    }
    
    public override void Update()
    {
        if(!client.IsOpened)
        {
             client.To.Open(new Host("1.1.1.1", 1111));
        }
        else
        {            
            if (Input.GetKeyDown(KeyCode.Space))
            {
                client.To.Data(message ?? "No message.", NE.Encoding.UTF8);
            }
        }
    }
}
```

</details>
</td>
</tr>

<tr><th></th></tr>

<tr>
<th align="center" valign="top"><sub><strong>Unity Engine</strong></sub></th>
<td>

<details><summary>üìÑ <strong><sup><sub>MonoBehaviour</sub></sup></strong></summary>

```csharp
using System;
using FlaxEngine;
using Netly;

public class Example : MonoBehaviour
{
    public string message;
    
    internal UDP.Client client;
    
    private void Awake()
    {
        client = new UDP.Client();        
        
        client.On.Open(() =>
        {
            Debug.Log(<some-text-here>);
        };
            
        client.On.Close(() =>
        {
            Debug.Log(<some-text-here>);
        };
            
        client.On.Error((exception) =>
        {
            Debug.Log(<some-text-here>);
        };
    }
    
    private void Start()
    {
        client.To.Open(new Host("1.1.1.1", 1111));
    }
    
    private void Update()
    {
        if(!client.IsOpened)
        {
             client.To.Open(new Host("1.1.1.1", 1111));
        }
        else
        {            
            if (Input.GetKeyDown(KeyCode.Space))
            {
                client.To.Data(message ?? "No message.", NE.Encoding.UTF8);
            }
        }
    }
}
```

</details>
</td>
</tr>

<tr><th></th></tr>

<tr>
<th align="center" valign="top"><sub><i>WARNING:</i></sub></th>
<td>

<sub>
<strong>You should never initialize events in an uncontrolled loop</strong>, (**.On) stores functions that will be
called when something happens and these functions only need to be initialized once. <i>Understand,
It doesn't mean that every event will only have one callback attached to it,
but it means not to keep calling (**.On) frequently like in Loops</i>.
See examples below of good and bad use.
</sub>
<br>
<br>
<sub>
For methods (**.To) there is an internal barrier that limits things like
(<i>trying to open or close connections several times, sending data with a disconnected socket, ...</i>) 
<strong>although these methods do not cause problems when called in a loop</strong>, <i>it is always good have the action and
state in sync</i>, for example <i>only</i> sending data when confirming that the <i>connection is open</i>.
</sub>
<br>
<br>

<details><summary>üìÑ <strong><sup><sub>Code</sub></sup></strong></summary>

```csharp
using System;
using Netly;


private HTTP.WebSocket ws;
```

```csharp
// OK
private void Init()
{    
    ws.On.Open(() => { ... });
    
    ws.On.Event((name, bytes) => { ... });

    ws.On.Event((name, bytes) =>
    {
        if (name == "foo") { ... }
    });

    ws.On.Event((name, bytes) =>
    {
        if (name == "bar") { ... }
    });
}
```

```csharp
// BAD
public void Loop()
{    
    
    client.To.Open(...);    // [OK]
    
    client.To.Data(...);    // [OK]
    
    client.To.Event(...);   // [OK]
    
    client.To.Close(...);   // [OK]   
    
    
    ws.On.Open(() => { ... });       // [NEVER IN LOOP]
    
    ws.On.Close(() => { ... });      // [NEVER IN LOOP]
    
    ws.On.Data((bytes) => { ... });  // [NEVER IN LOOP]    
    
    ws.On.Error((exception) => { ... });    // [NEVER IN LOOP]
    
    ws.On.Event((name, bytes) => { ... });  // [NEVER IN LOOP]    
}
```

</details>
</td>
</tr>
</table>
